<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>吟求 - IT技术文章分享</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="吟求是一个互联网技术分享的站点，汇聚了java、php、node.js、html5等最新技术实时文章">
<meta name="keywords" content="IT文章聚合，IT文章分享，IT阅读分享">
<meta property="og:type" content="website">
<meta property="og:title" content="吟求 - IT技术文章分享">
<meta property="og:url" content="http://dodoing.com/page/5/index.html">
<meta property="og:site_name" content="吟求 - IT技术文章分享">
<meta property="og:description" content="吟求是一个互联网技术分享的站点，汇聚了java、php、node.js、html5等最新技术实时文章">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吟求 - IT技术文章分享">
<meta name="twitter:description" content="吟求是一个互联网技术分享的站点，汇聚了java、php、node.js、html5等最新技术实时文章">
  
    <link rel="alternate" href="/atom.xml" title="吟求 - IT技术文章分享" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">吟求 - IT技术文章分享</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://dodoing.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-YY游戏云平台在AngularJS上的实践总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/YY游戏云平台在AngularJS上的实践总结.html" class="article-date">
  <time datetime="2016-12-06T10:19:00.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/06/YY游戏云平台在AngularJS上的实践总结.html">YY游戏云平台在AngularJS上的实践总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>导语</p>
</blockquote>
<p>云平台控制台，是一个典型的管控CRUD系统，用于管理各种IaaS资源。</p>
<p>为了使前端能达到仿客户端体验，同时保障代码架构清晰规范，易维护，最终多玩YY选择了AngularJS（1.x）作为云控制台的前端框架。</p>
<p>本文主要围绕AngularJS（1.x），介绍多玩YY在开发控制台过程中的点点滴滴。</p>
<blockquote>
<p>为什么选择AngularJS</p>
</blockquote>
<p>轻松构建单页面应用</p>
<p>可以说，这是我们最终选择AngularJS的重要原因，如果你希望构建一个结构清晰、可维护、开发效率高、体验好的单页应用，AngularJS是相当不错的框架。</p>
<p>单页面应用的魅力</p>
<p><strong>什么是单页面应用？</strong></p>
<p>单页应用，指一种基于Web的应用或者网站，页面永远都是局部更新元素，而不是整页刷新，给用户的感觉就像整个网站都是一个页面。</p>
<p>当用户点击某个菜单或者按键时，不会跳转到其他页面，前端会从后端获取对应页面的数据而不是HTML，之后在页面中需要更新内容的地方，局部动态刷新，而如果是传统的多页网站，当用户访问不同的页面时，服务器会直接返回一个HTML，然后浏览器负责将这个HTML展现给用户。目前，</p>
<p>大部分云控制台，都是单页应用架构，单页应用能带来一种更近似客户端，而不是网页的体验。</p>
<p>单页面应用网站，在体验方面，具有如下优点：</p>
<p>做“页面跳转”时，永远都是局部动态刷新，用户不会感觉整个屏幕闪了一下，而仅仅是需要变化的区域做了局部刷新。</p>
<p>例如两个不同的页面，假设页面元素都是一样的，只是元素中的文字不一样（例如每个页面都有一个面包屑，一排按钮及一个表格，这几个元素的布局也是一样的），当用户跳转到另外一个页面时，会看到整个页面并没有重新渲染，只是文字发生了变化。简单地说，这有点类似使用App，永远都是局部发生变化，你见过哪个App，当点击到不同的功能视图时，整个屏幕会白屏闪一下的么？</p>
<p>URL可收藏，可回退。</p>
<p>如果浏览器的URL一直不变，那还不能称为真正的单页应用。不同的功能，不同的资源页面，对应的URL是不一样的。</p>
<p>当用户跳转到另外的功能时，会发现URL会变成对应的值；通过回退键，也可以回到之前浏览的页面。</p>
<p>这个特性有什么用呢？如果URL不会随着功能而变化，当用户刷新当前页面时，就会回到之前的默认页面，而不是预期的当前功能页面，同样的，URL也不具备可收藏性，因为点开之前收藏的URL，永远都是网站的默认页面。这对一些强交互的管控系统来说，体验不好。</p>
<p>功能切换时快速流畅。快速流畅主要因为两个原因：</p>
<pre><code>一是页面都是局部刷新，从用户感官来说更快

二是和后台通信的内容，都是数据，而不是页面模板，请求量更少；而传统网站，在访问不同页面时，服务端返回的是HTML，体积更大，而且还需要一直重复加载JavaScript、CSS文件。
</code></pre><p>因为网站的单页化，可以更好地使用全局类的交互（做页面切换时，需要一直保持不变的交互）。</p>
<p>例如，页面上需要显示某次耗时操作的进度，例如上传文件进度，耗时操作的当前状态等，你可以在页面最右侧固定显示进度。当用户访问单页应用时，他会明白，当点击其他模块时，这个右侧的通知栏不会消失，会固定显示。</p>
<p>而如果是多页网站，用户则会困惑，担心自己跳转到其他页面后，进度通知就会消失。</p>
<p>AngularJS是开发单页应用的利器</p>
<p>单页面应用对于代码分层，结构清晰有更高的要求，而AngularJS是一个MVVM框架，其自身的约定，减少了我们写出“一锅粥”代码的可能性（在下面讨论“编写更易维护的代码”时会详述）。</p>
<p>AngularJS的著名第三方组件UI-Router，是一个控制页面路由的组件，它支持我们快速搭建单页应用（AngularJS本身的路由功能也可以，但功能会稍微弱一些）。</p>
<p>AngularJS的检查更新机制，使页面刷新时更加快速自然。 当数据“可能”发生变化时，AngularJS会检查出所有变化的元素，再“一次性”刷新所有变化的UI元素。</p>
<p><strong>编写更易维护的代码</strong></p>
<p>很多人经常会抱怨，不同水平的人凑在一起写JavaScript，到最后项目经常就是一锅粥，同一个JavaScript文件里面，各种各样的逻辑都混在一起，要增删功能，简直是恶梦。无规矩不成方圆。</p>
<p>作为框架，AngularJS无疑能大大改善这种状况，使得项目整体的分层明了，职责清晰。</p>
<p>在笔者看来，AngularJS能够帮助我们编写更易维护的代码，</p>
<pre><code>一是因为其“关注点分离”的理念

二是因为其强大的特性为项目节省了不少代码量，从而降低程序员犯错的概率。
</code></pre><p><strong>关注点分离</strong></p>
<p>关注点分离是AngularJS的一大设计哲学。</p>
<p>所谓关注点分离，指的是各个逻辑层职责清晰明确。</p>
<p>例如，当你需要修改甚至替换展现层时，无需关注业务层是怎么实现的。</p>
<p>在AngularJS中，服务层（Ajax请求）- 业务层（Controller）- 展现层（HTML 模板）- 交互层（animation）这些都有对应的基础组件。</p>
<p>不同组件职责不同，也很难将本属于B组件的职责放到A组件上去实现。</p>
<p>举几个例子：</p>
<p>HTML及Controller需要协同工作，但职责分明。视图、交互层面的逻辑，例如展示隐藏某些元素，是HTML模板的职责，Controller只能用于数据初始化。</p>
<p>如果你反其道而行，想在Controller中做HTML模板做的事情，将会非常别扭。这一点非常重要，传统的JavaScript代码，经常会出现的情况，就是JavaScript里面会有大量DOM操作的逻辑，同时还有大量数据操作相关的逻辑，这些逻辑耦合到一起，当需要单独重构数据层或者视图层时（例如项目UI改版），都会捉襟见肘，同时，由于JavaScript代码量的迅速膨胀，维护起来也会很麻烦。</p>
<p>你无法将后台通信逻辑放到Controller中实现，而要放到Factory中。</p>
<p>后台通信逻辑，一般要做成公用的。而由于Controller之间是不能相互调用的，所以你也不可能将后台通信逻辑放到其中一个Controller，然后其他Controller来调用这个Controller暴露的接口。</p>
<p>唯一的办法，就是将后台通信逻辑放到Factory或者Service中。</p>
<p>Filter及Directive看似都可以用于数据转换，但实则不同。由于Filter只能做数据格式化，不支持引入模板，所以公用的UI交互，涉及到DOM元素或者需要引入HTML模板时时，也只能通过Directive来实现。</p>
<p>综上所述，AngularJS项目，其展现层、交互层的逻辑，都是在HTML或者指令中，服务层（后台通信），只适合出现在Factory（或者Service）中，而业务层则由Controller来负责。这样每层的逻辑都是轻薄的，而不是纠结在一起。 如果你只是要优化展示逻辑，那改改HTML就可以了，不用去管Controller是怎么写的。这</p>
<p>一点我们有亲身体会。项目开发过程中，我们重构了视觉效果，所有的HTML都要重写。但在重构时，我们的Controller、后台通信（Service）、Filter基本都不用改，只要改HTML就行了。而如果项目是用jQuery写的，显然不可能做到，你需要重新为新的HTML增加一些可供jQuery选择器使用的class或id，然后需要在JavaScript里面绑定事件，根据新的CSS样式名来写新的交互效果，而在AngularJS上，有些不用做了（例如为了jQuery选择器，而为HTML元素增加新的class、id；在JavaScript中绑定事件），有些（例如交互效果）则只要改HTML就行，而不是改JavaScript。</p>
<p><strong>AngularJS为我们省去的代码量</strong></p>
<p>对于任何项目来说，代码臃肿、冗余是可维护性的天敌。</p>
<p>因此，实现同样的功能，代码量越少，抽象度越高，冗余度越低，在某种程度上意味着项目更方便维护。而能减少代码量，也是AngularJS被推崇的一大优点。让我们来看看，它是如何减少了代码量的：</p>
<p>首先，作为一个大而全的框架（双刃剑，有利有弊)，AngularJS提供的诸多特性，使我们可以更专注于业务代码的编写。</p>
<p>其次，AngularJS双向数据绑定的特性，将我们从大量的值绑定代码中解放出来。</p>
<p>和jQuery对比，AngularJS不用为了选择某个元素，而刻意为HTML加上一些跟样式无关的class、2-2-2. id；</p>
<p>不用写一堆从HTML元素中取值，设值的代码；不用在JavaScript代码中绑定事件；不用在JavaScript值发生变化时写代码去更新HTML对应的值。</p>
<p>双向数据绑定，让我们告别很多简单无趣的绑定事件、绑定值的代码。</p>
<p>Directive、Filter、Factory等，天然的就是一个个可以复用的组件，减少了冗余重复代码。一些需要公用的逻辑，如果放在Controller中，都会相当别扭，就这样被AngularJS“逼着”，把公用逻辑都放到Directive、Filter、Factory中去。</p>
<hr>
<blockquote>
<p>开发心得总结</p>
</blockquote>
<p><strong>我理解的AngularJS基础组件</strong></p>
<p>化繁为简，几大基础组件的使用场景</p>
<p>首先我们需要理清AngularJS几个组件的使用场景。</p>
<p>AngularJS的一个毛病，就是新概念，新特性太多，新手一下子要了解这么多，学习曲线略陡。</p>
<p>为了帮助大家理解，总结下我理解的几大组件使用场景。<br>请求资源与数据缓存的东西放进Service。Factory、Service本质上都是Provider的语法糖，两者只是使用方式有所不同，建议大家直接都用Service，ES6 class更容易，之后想平滑迁移到Angular2也会更容易，同时也能避免团队成员在选择Service还是Factory时产生困惑。</p>
<p>数据需要格式化的东西用Filter处理。例如把status值转化为中文值，把时间戳转成时间字符串之类。</p>
<p>需要公用的DOM操作，放在指令中去写。另外，如果需要引入jQuery组件，也可以写个指令把jQuery组件初始化代码放进去。</p>
<p>Controller与视图按照一对一的关系维护，在Controller内初始化Scope对象与在Scope上添加方法（行为），为ViewModel做赋值。其他所有过程都不应该出现在Controller中。</p>
<p>Controller中不应该出现和页面展示、交互相关的代码。例如展示隐藏某些元素之类，这些应该是HTML模板或者指令负责。代码越薄越好。</p>
<p>全局常量值放到Constant。</p>
<p>指令（Directive）魔法</p>
<p>指令这个特性，用“魔法”一词来形容它，都不为过。</p>
<p>解决的痛点：一言以蔽之，指令提供了一套前端组件化的方法及约定，这使得编写，使用UI组件更加方便了。相对于jQuery，它解决了以下痛点：</p>
<p>动态生成了HTML元素后，不用再手动去为其加上JavaScript特性。</p>
<p>举个例子：HTML原生的checkbox框比较丑，在jQuery时代，可以将checkbox替换成自定义的效果，如果是页面一开始就有的checkbox，我们可以在document.ready的时候调用自定义checkbox的初始化方法。但是，如果这个checkbox是动态生成的，在每个动态生成checkbox的地方，我们都得去调用checkbox的初始化方法，相当麻烦。但用了AngularJS的指令，就不会有这个问题了，只要在模板的chceckbox中加上指令，不管这个模板是动态变化的还是静态的，无需通过业务代码来逐个调用初始化方法，呈现给用户的，就已经是AngularJS替换后的checkbox效果。</p>
<p>一个组件的HTML和JavaScript，是一个整体，而不是割裂的（题外话，这一点React做得比Angular1.x还要好）。</p>
<p>基于jQuery的UI组件，其引入方法，经常是这样的，首先，要求你自己copy一段指定的HTML，然后再调用初始化方法。而指令则支持定义对应的模板HTML，用户在引入时，可能只要写一个指令标签，就会自动生成N行的HTML及绑定对应的JavaScript效果。</p>
<p>当然，理论上jQuery也能做到这样，但是会比Angular的实现麻烦许多。</p>
<p>应用、移除UI特性时方便直观。</p>
<p>假设有这么一个需求，给一个普通输入框增加输入限制，只能输入特定字符（如字母数字），写好对应指令，只要给这个input输入框加上这个指令标签，就能马上应用这个特性，之后要移除，只要把标签去掉就好。</p>
<p>相比之下，jQuery就会麻烦多。jQuery下，一般是通过元素选择器来绑定JavaScript效果。因此，在添加该特性时，你需要考虑给对应的输入框指定一个合适的元素选择器。移除特性时，你要考虑：有可能你在动态生成输入框的地方，都加了这些初始化代码，这些JavaScript都需要移除；如果元素选择器用的是class，得考虑是不是其他输入框也有这个class，如果是，那么移除代码时也会影响到其他输入框。</p>
<p><strong>技巧</strong></p>
<p>如果你迫不得已需要引入jQuery组件，你可以写一个指令把它包装起来，在该指令中初始化组件。</p>
<p>要注意require参数中的值是驼峰的，在HTML中就得转成对应的中划线命名，例如有require参数phoneKey，那么HTML中应为phone-key=”xxx”。</p>
<p>虽然这个道理很浅显，但经常一不小心就会弄错了，然后发现在指令内部怎么着都拿不到require参数。</p>
<p>如果你在link中加了elm.bind(‘click’)，当click回调函数中，作用域的值发生变化，记得调用scope.$apply()，否则值变化不会生效。</p>
<p><strong>文件、目录约定</strong></p>
<p><em>目录结构</em></p>
<p>第三方库、CSS、图片放置到哪个目录，不在本文讨论范围，这里略过。需要进一步说明的，是业务代码目录。</p>
<p>我们将系统自身的JavaScript、HTML模板都放在pages目录，其中子目录common放置公用的JavaScript及模板；<br>其他子目录，以功能模块名作为目录名，然后将这个模块相关的JavaScript及模板放在其中。</p>
<p>这样开发同个模块功能时，可以方便地在HTML及对应JavaScript之间切换。</p>
<p>有些代码规范可能还会建议在模块这一级目录下，再根据AngularJS的几大组件Controller、Filter、Service等，创建不同的子目录，例如模块A/controller，模块A/service之类，我们则将所有JavaScript及HTML放在同一级，这样做主要有几个原因：</p>
<p>我们的项目，平均每个模块只有十来个文件，特别是每个模块一般只有一个Filter及Service，为了这一个文件创建一个目录，显得多此一举。</p>
<p>通过文件名，已经可以很方便地区分不同的JavaScript组件类型及HTML模板类型，同时，由于IDE一般会按照文件名字母排序，所以相同功能的JavaScript及HTML会挨在一起，查找对应的模板或JavaScript代码会方便很多。</p>
<p><em>文件名约定</em></p>
<p>这个约定对于Angular来说，特别重要。具体的约定是：</p>
<p>例如，为“防火墙”模块开发“创建防火墙”的功能，它的Controller，对应的JavaScript为：firewall.create.ctrl.js，对应的HTML模板为：</p>
<p>firewall.create.ctrl.HTML。为了文件名书写的方便，定义了组件的简写：controller -&gt; ctrl ；factory,service -&gt; svr ； filter-&gt; fil ； directive -&gt; dire。</p>
<p>这样约定有两个显而易见的优点：</p>
<p>通过文件名，就能知道对应模块、AngularJS基本组件类型、是模板HTML还是JavaScript 。</p>
<p>相同功能的JavaScript及HTML，会挨在一起（如果IDE是按照文件命名排序）。</p>
<p><em>与后端服务器通信</em></p>
<p>根据后台接口规范，结合AngularJS自身能力，我们做了一些封装，使接口请求逻辑变得非常简单。具体问题具体分析，先看看我们的后台接口的标准响应格式是怎样的，前端会按照这个接口返回格式做一些定制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">errno</span>:<span class="number">0</span>, <span class="attr">errmsg</span>:<span class="string">""</span>, <span class="attr">data</span>:[ &#123; <span class="attr">id</span>:<span class="string">"test"</span>, <span class="attr">name</span>:<span class="string">"test"</span> &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们项目服务端的标准响应是一个json，通过errno描述此次请求的结果码，通过errmsg描述出错的原因（假如请求出错的话），通过data返回正常数据。</p>
<p><em>出错处理</em><br>当接口返回的errno!=0时，说明接口返回异常（系统异常或用户输入错误），这时我们希望能弹框提示用户“出错了”。显然，如果在每个接口请求逻辑中，都去写这个逻辑，会非常累赘，所幸AngularJS提供了拦截器的功能，我们只要写一个拦截器，就可以对所有的异常返回做统一处理。 </p>
<p>首先，我们需要显式地抛出HTTP错误。因为当后台逻辑出错或者用户输入参数有误时，返回的HTTP状态码都是200（这只是我们项目的约定），AngularJS并不会认为200是出错的情况，因此，我们需要做点小动作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">$httpProvider.defaults.transformResponse.push(<span class="function"><span class="keyword">function</span> (<span class="params">responseData</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (responseData.errno != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> responseData;</div><div class="line">            &#125;</div><div class="line">            ……</div><div class="line">      &#125;);</div><div class="line">AngularJS的</div><div class="line">httpProvider.interceptors捕获这个异常并弹框，代码如下：</div><div class="line">$httpProvider.interceptors.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">     <span class="attr">responseError</span>: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">       <span class="keyword">if</span> (response) &#123;</div><div class="line">          <span class="keyword">if</span> (response.hasOwnProperty(<span class="string">"errmsg"</span>)) &#123;</div><div class="line">              <span class="keyword">if</span> (response.errno &gt; <span class="number">0</span>) &#123;</div><div class="line">                                alert(response.errmsg);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">             alert(<span class="string">"系统维护中，请稍候重试"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (response.status == <span class="number">404</span>) &#123;</div><div class="line">               alert(<span class="string">"抱歉，后台服务出错,找不到对应的接口"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                alert(<span class="string">"抱歉，后台服务出错"</span>);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>有些人可能会问，为啥不直接在一开始的transformResponse函数中写错误处理逻辑呢？</p>
<p>这是因为，接口正常时，AngularJS会依次调用transformResponse函数，再调用interceptors的responseError。</p>
<p>但是，某些异常情况，并不会调用transformResponse逻辑，例如，当URL不存在时，Web容器默认返回的404页面，或者当程序出错时，系统代码未处理这个错误，Web容器会返回默认的500页面，这时均会直接进入interceptors的responseError中。</p>
<p>因此，为了覆盖所有的异常情况，需要在transformResponse中抛出异常，然后由responseError统一处理。</p>
<p>2 响应内容格式化</p>
<p>由于前端关心的数据，是放在响应内容的data属性中。</p>
<p>而另外两个属性errno、errmsg，当返回正常数据时，前端是不关心的，为了取数据时更加方便，可以进一步优化transformResponse中的处理。当errno==0时，都返回responseData.data，这样，在业务逻辑里面，就可以直接使用data了，而不用取xxx.data。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$httpProvider.defaults.transformResponse.push(<span class="function"><span class="keyword">function</span> (<span class="params">responseData</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (responseData &amp;&amp; responseData.hasOwnProperty(<span class="string">"errno"</span>) &amp;&amp; responseData.hasOwnProperty(<span class="string">"errmsg"</span>) &amp;&amp; responseData.hasOwnProperty(<span class="string">"data"</span>)) &#123;</div><div class="line">            <span class="keyword">if</span> (responseData.errno == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (Angular.isArray(responseData.data) || Angular.isObject(responseData.data)) &#123;</div><div class="line">                    <span class="keyword">return</span> responseData.data;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> responseData</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> responseData;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> responseData;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>3 对$resource做进一步封装</p>
<p>项目中每个模块，都创建了对应的service文件，用于与后台进行通信。例如“硬盘”模块，对应DiskSvr，“防火墙“模块，对应FirewallSvr。这样划分后，前端所有的后台请求逻辑，找起来会很方便。</p>
<p>在封装后台通信逻辑时，我们用到$resource，这是AngularJS自身的一个组件，当你的后台接口符合RESTFul规范时，你可以很方便地使用resource和后台进行通信。</p>
<p>而由于我们的后台并不是完整的RESTFul实现，我们需要做一些简单的封装。示意代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">app.factory(<span class="string">"DiskSvr"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> url = <span class="string">"schedule/disk"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> customAPI = &#123;</div><div class="line">        <span class="attr">clone</span>: &#123;</div><div class="line">            <span class="attr">method</span>: <span class="string">"post"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> getApi(url, customAPI);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//公用的，每个Svr都可以用</span></div><div class="line">getApi = <span class="function"><span class="keyword">function</span> (<span class="params">path, customAPI</span>) </span>&#123;</div><div class="line"></div><div class="line">    Angular.forEach(customAPI, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!value.url) &#123;</div><div class="line">            value.url = util.connectPath(path, key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            value.url = util.connectPath(path, value.url);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//所有的</span></div><div class="line">    <span class="keyword">var</span> defaultAPI = &#123;</div><div class="line">        <span class="attr">detail</span>: &#123;</div><div class="line">            <span class="attr">url</span>: baseUrl + <span class="string">"/get"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">delete</span>: &#123;</div><div class="line">            <span class="attr">url</span>: baseUrl + <span class="string">"/delete"</span>,</div><div class="line">            <span class="attr">method</span>: <span class="string">"delete"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">create</span>: &#123;</div><div class="line">            <span class="attr">url</span>: baseUrl + <span class="string">"/create"</span>,</div><div class="line">            <span class="attr">method</span>: <span class="string">"post"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">update</span>: &#123;</div><div class="line">            <span class="attr">url</span>: baseUrl + <span class="string">"/update"</span>,</div><div class="line">            <span class="attr">method</span>: <span class="string">"put"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> $resource(path, &#123;&#125;, Angular.extend(defaultAPI, customAPI));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码，主要做了这些事情：</p>
<p>为所有的svr注入了每个模块接口都必备的，最基础的增删改查四个接口。这样就无需在每个svr中加入这些接口。例如，在业务逻辑中调用DiskSvr.create()，就会用post请求调用schedule/disk/create接口。</p>
<p>简化了新增接口的配置。新增一个接口，只要配置对应的HTTP方法及名字即可。</p>
<p>通过引用$resource组件、进一步封装及svr文件，在业务Controller中，不会看到任何的和后台通信的基础代码，如果在这个Controller中你需要和后台通信，你只需注入响应的svr，然后调用对应方法即可。</p>
<p>4 注入请求header头</p>
<p>在我们的项目中，约定了所有的请求都要在header中带上一些相同的信息，这对AngularJS来说，是非常简单的事情： 执行以下代码后，之后所有的HTTP请求都会带上名为project的header信息：</p>
<p>Controller间通信问题</p>
<p>Controller调用</p>
<p>假设controllerA希望调用controllerB的某个函数，告诉同伴Controller，我的某个你所关心的东西改变了，要怎么做呢？举具体业务场景，有两个Controller，一个是主页Controller，另外主页上有个弹框表单，这个弹框表单也有个Controller，用户成功提交了这个表单后，弹框Controller需要告知</p>
<p>主页Controller，“哥们，请更新主页上的某项数据”。建议的做法，是用AngularJS的消息机制。例如，上面的例子中，弹框Controller是主页Controller的子Controller。</p>
<p>那么弹框Controller可以往上冒泡传递消息：</p>
<p>其父Controller去捕获这个消息：</p>
<p>这是一种很好的解耦办法，假设这两个Controller是由两个开发负责的，那么我开发我的Controller，你开发你的，我不用去关心你那边的逻辑。</p>
<p>2 数据共享</p>
<p>多个Controller之间要共享数据，要怎么做呢？ </p>
<p>最简单但也不推荐的一个做法，就是把数据塞到rootscope中，但是，这就像JavaScript的全局变量，野蛮不好控制。 </p>
<p>这里推荐下我们的做法：写一个专门用于存储、设置共享数据的共享数据Facoty。在里面定义set方法，所有的共享变量，都需要经过set方法来设置。然后取数据则通过DATA变量获取。 </p>
<p>伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">app.factory(‘ShareSvr’, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> shareData = &#123;</div><div class="line">peopleNum</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line"><span class="attr">DATA</span>:shareData,</div><div class="line"><span class="attr">setPepleNum</span>:<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">shareData.peopleNum = num;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">app.controller(‘TestController’,<span class="function"><span class="keyword">function</span>(<span class="params">ShareSvr</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">this</span>.DATA = ShareSvr.DATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里并没有要求DATA值只能通过g alert(“Hello CSDN”); et方法获取，是为了之后在Controller对应的视图HTML中取值方便些。</p>
<p>第三方 库/资源 推荐</p>
<p>UI Router</p>
<p>路由（route），几乎所有的MVC框架都应该具有的特性，它是前端构建单页面应用（SPA）必不可少的组成部分。相比原生的ngRouter，UI Router功能更加强大，具备多视图，嵌套路由等特性，可以解决路由大部分的应用场景。</p>
<p>ngDialog</p>
<p>一个弹框控件，功能强大，我比较喜欢的地方，是它没有写死弹框的HTML、可以很方便地定义自己想要的弹框模板。例如，我们项目就通过它做了两种弹框，一种是普通弹框，一种是侧拉框（从屏幕右侧滑出，占满浏览器高度，宽度占满一半屏幕（或者其他自定义宽度）。</p>
<p>AngularJS代码规范</p>
<p><code>3-1. https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md</code></p>
<p><code>3-2. https://github.com/mgechev/Angularjs-style-guide/blob/master/README-zh-cn.md</code></p>
<p>Angular-filter</p>
<p>提供了很多实用的filter，string类、math类，集合类等。</p>
<p>w5c-validator</p>
<p>基于Angular.js原有的表单验证，统一验证规则和提示信息，在原有的基础上扩展了一些错误提示的功能，让大家不用在每个表单上写一些提示信息的模板，专心的去实现业务逻辑，国人出品。</p>
<p>ng-table</p>
<p>轻量，功能强大的表格组件。可以很方便地修改表格的样式、交互效果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dodoing.com/2016/12/06/YY游戏云平台在AngularJS上的实践总结.html" data-id="cj4rusztm0008v0e97z4iaivh" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-angular父controller、子controller、同级controller之间的通讯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/02/angular父controller、子controller、同级controller之间的通讯.html" class="article-date">
  <time datetime="2016-12-02T07:19:00.000Z" itemprop="datePublished">2016-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/02/angular父controller、子controller、同级controller之间的通讯.html">angular父controller、子controller、同级controller之间的通讯</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在同个  angular.js 应用的控制器之间进行通信可以有很多种不同的方式，本文主要讲两种：</p>
<ul>
<li>基于scope继承的方式</li>
<li>基于event传播的方式</li>
</ul>
<blockquote>
<p>基于scope继承的方式</p>
</blockquote>
<p>最简单的让控制器之间进行通信的方法是通过scope的继承。</p>
<p>假设有两个控制器Parent、Child，Child 在 Parent 内，那Child 可以称为子控制器，它将继承父控制器Parent的scope。</p>
<p>这样，Child就可以访问到Parent的scope中的所有函数和变量了。<br>需要注意的是，由于scope的继承也是基于Js的原型继承，如果变量是基本类型的，那在Child中的修改（写），有可能会导致Parent中的数据变脏</p>
<p>基本类型变量的继承</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Sandcrawler($scope) &#123;</div><div class="line">    $scope.location = 'Mos Eisley North';</div><div class="line">    $scope.move = function(newLocation) &#123;</div><div class="line">        $scope.location = newLocation;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Droid($scope) &#123;</div><div class="line">    $scope.sell = function(newLocation) &#123;</div><div class="line">        $scope.location = newLocation;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller="Sandcrawler"&gt;</div><div class="line">    &lt;p&gt;Location: &lt;/p&gt;</div><div class="line">    &lt;button ng-click="move('Mos Eisley South')"&gt;Move&lt;/button&gt;</div><div class="line">    &lt;div ng-controller="Droid"&gt;</div><div class="line">        &lt;p&gt;Location: &lt;/p&gt;</div><div class="line">        &lt;button ng-click="sell('Owen Farm')"&gt;Sell&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>看完上面的代码我们知道，location 属性是直接被注册到 $scope 中的，Droid控制器所拥有的scope从Sandcrawler控制器的scope中继承了这个属性并且可以读取它。</p>
<p>看以下两个假设场景：</p>
<p>如果 Sandcrawler 中改变了 location 属性，在 Droid 中也会读取到这个改变；</p>
<p>在 view 中的表现则是：点击了 Move 按钮的话，两个 p 标签都会显示 Mos Eisley South</p>
<p>反过来，如果 Droid 中对 $scope.location 进行改写，它只改写自己scope中 location 属性的值，它不会影响 Sandcrawler 中的这个属性的值；</p>
<p>在 view 中的表现则是：当点击了 Sell 按钮之后，两个控制器scope之间的数据共享就不复存在了，之后无论点多少次 Move 按钮，都影响不了 Droid 中的 p 标签的显示了</p>
<p>经过上面的教训，有时候我们想要达到的效果可能达不到（如点了 Sell 按钮之后再点 Move 还想让它起作用），这样在ng的开发者中逐渐达成了一个一致的约定，千万不要把那些可以被子级scope改写的属性用基础类型直接添加在 $scope 对象上，而是应该尽可能地用对象类型去添加</p>
<p><em>对象类型变量的继承</em></p>
<p>通过上面的结论我们知道，可以用对象类型的变量来作为属性添加到 $scope 中去，这样，只要是引用了这个对象的，无论是谁，在哪个控制器里面，对这个对象变量的改写都会影响都所有引用了这个对象的实例。</p>
<p>看下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Sandcrawler($scope) &#123;</div><div class="line">    $scope.sandcrawler.location = 'Mos Eisley North';</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Droid($scope) &#123;</div><div class="line">    $scope.summon = function(newLocation) &#123;</div><div class="line">        $scope.sandcrawler.location = newLocation;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller="Sandcrawler"&gt;</div><div class="line">    &lt;p&gt;Sandcrawler Location: &lt;/p&gt;</div><div class="line">    &lt;div ng-controller="Droid"&gt;</div><div class="line">        &lt;button ng-click="summon('Owen Farm')"&gt;</div><div class="line">            Summon Sandcrawler</div><div class="line">        &lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>跑一下上面的代码就知道，当我们使用“召唤术”的时候，可以改写 Sandcrawler 控制下的 p 标签的显示了</p>
<blockquote>
<p>基于event传播的方式</p>
</blockquote>
<p>基于scope继承的方式只能处理父子级控制器之间的通信问题，不能处理兄弟/相邻控制器之间的通信问题。</p>
<p>这时候，我们需要使用基于event传播的方式来进行通信，这里，ng为我们提供了三个方法：$on , $emit , $broadcast ，需要明确的是：这种方法不仅可以处理兄弟scope间的通信问题，对于解决父子scope间的通信也是毫无压力</p>
<p><strong>子–&gt;父：$emit</strong></p>
<p>整个过程是这样的：</p>
<p>子scope中的控制器通过 $scope.$emit 触发一个事件向上传播</p>
<p>这个事件会经过每一层的父scope，至于处不处理是父scope自己的事情了</p>
<p>如果处理，就在想要处理的那个祖先scope中放一个 $scope.$on 监听着就行了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 父scope上的控制器</div><div class="line">function Sandcrawler($scope) &#123;</div><div class="line">    $scope.location = 'Mos Eisley North';</div><div class="line">    $scope.$on('summon', function(e, newLocation) &#123;</div><div class="line">        $scope.location = newLocation;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// 子scope上的控制器</div><div class="line">function Droid($scope) &#123;</div><div class="line">    $scope.location = 'Owen Farm';</div><div class="line">    $scope.summon = function() &#123;</div><div class="line">        $scope.$emit('summon', $scope.location);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller="Sandcrawler"&gt;</div><div class="line">    &lt;p&gt;Sandcrawler Location: &lt;/p&gt;</div><div class="line">    &lt;div ng-controller="Droid"&gt;</div><div class="line">        &lt;p&gt;Droid Location: &lt;/p&gt;</div><div class="line">        &lt;button ng-click="summon()"&gt;Summon Sandcrawler&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>跟我之前写的一篇DOM事件一样，如果你不想让你的事件再往更上层传播，在 $on 中的处理函数调用 e.stopPropagation() 即可</p>
<p><strong>父–&gt;子：$broadcast</strong></p>
<p>接下来的东西就简单了，从父到子，用另外一个方法就是了，同样用 $on 监听着，all done，看下面代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 父scope上的控制器</div><div class="line">function Sandcrawler($scope) &#123;</div><div class="line">    $scope.location = 'Mos Eisley North';</div><div class="line">    $scope.recall = function() &#123;</div><div class="line">        $scope.$broadcast('recall', $scope.location);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 子scope上的控制器</div><div class="line">function Droid($scope) &#123;</div><div class="line">    $scope.location = 'Owen Farm';</div><div class="line">    $scope.$on('recall', function(e, newLocation) &#123;</div><div class="line">        $scope.location = newLocation;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller="Sandcrawler"&gt;</div><div class="line">    &lt;p&gt;Sandcrawler Location: &lt;/p&gt;</div><div class="line">    &lt;button ng-click="recall()"&gt;Recall Droids&lt;/button&gt;</div><div class="line">    &lt;div ng-controller="Droid"&gt;</div><div class="line">        &lt;p&gt;Droid Location: &lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>同级之间</p>
<p>拥有同个父scope的子级scope之间，也就是兄弟/相邻scope之间的通信，其实是借助“奶爸”传递消息的：</p>
<p>子级scope中有谁想传消息了，$emit 一个给“奶爸”</p>
<p>然后通过“奶爸” $broadcast 给所有孩子这个相同的信息，当然发出信息的那个可以选择是否要忽略掉自己发出的信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 父scope上的控制器</div><div class="line">function Sandcrawler($scope) &#123;</div><div class="line">    $scope.$on('requestDroidRecall', function(e) &#123;</div><div class="line">        $scope.$broadcast('executeDroidRecall');</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// 子scope上的控制器</div><div class="line">function Droid($scope) &#123;</div><div class="line">    $scope.location = 'Owen Farm';</div><div class="line">    $scope.recallAllDroids = function() &#123;</div><div class="line">        $scope.$emit('requestDroidRecall');</div><div class="line">    &#125;</div><div class="line">    $scope.$on('executeDroidRecall', function() &#123; </div><div class="line">        $scope.location = 'Sandcrawler';</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller="Sandcrawler"&gt;</div><div class="line">    &lt;div ng-controller="Droid"&gt;</div><div class="line">        &lt;h2&gt;R2-D2&lt;/h2&gt;</div><div class="line">        &lt;p&gt;Droid Location: &lt;/p&gt;</div><div class="line">        &lt;button ng-click="recallAddDroids()"&gt;Recall All Droids&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div ng-controller="Droid"&gt;</div><div class="line">        &lt;h2&gt;C-3PO&lt;/h2&gt;</div><div class="line">        &lt;p&gt;Droid Location: &lt;/p&gt;</div><div class="line">        &lt;button ng-click="recallAddDroids()"&gt;Recall All Droids&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>上面代码中要注意的是：子scope通过 $emit 发出的事件名不能与父scope用 $broadcast 的事件名一样，如果有传参数，那当然参数可以一样，因为参数就是我们要传的数据。</p>
<p>事件名不能一样是为了防止进入死循环。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dodoing.com/2016/12/02/angular父controller、子controller、同级controller之间的通讯.html" data-id="cj4rusztp0009v0e9463n02f9" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JSONP的原理，JSON和JSONP区别，也许你会豁然开朗，含jQuery用例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/30/JSONP的原理，JSON和JSONP区别，也许你会豁然开朗，含jQuery用例.html" class="article-date">
  <time datetime="2016-11-30T09:21:00.000Z" itemprop="datePublished">2016-11-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/30/JSONP的原理，JSON和JSONP区别，也许你会豁然开朗，含jQuery用例.html">JSONP的原理，JSON和JSONP区别，也许你会豁然开朗，含jQuery用例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>前言</p>
</blockquote>
<p>说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？</p>
<p>这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。</p>
<p>但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。</p>
<p>JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。</p>
<p>我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。</p>
<p>看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。</p>
<p>既然随便聊聊，那我们就不再采用教条的方式来讲述，而是把关注重心放在帮助开发人员理解是否应当选择使用以及如何使用上。</p>
<blockquote>
<p>什么是JSON？</p>
</blockquote>
<p>前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。</p>
<p>JSON的优点：</p>
<ol>
<li>基于纯文本，跨平台传递极其简单；</li>
<li>Javascript原生支持，后台语言几乎全部支持；</li>
<li>轻量级数据格式，占用字符数量极少，特别适合互联网传递；</li>
<li>可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的；</li>
<li>容易编写和解析，当然前提是你要知道数据结构；</li>
</ol>
<p>JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。</p>
<p>JSON的格式或者叫规则：</p>
<p>JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。</p>
<p>1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号””是定义符。</p>
<p>2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。</p>
<p>3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。</p>
<p>4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号””，以便于不同语言的解析。</p>
<p>5、JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。</p>
<p>JSON实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 描述一个人</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="string">"Name"</span>: <span class="string">"Bob"</span>,</div><div class="line">    <span class="string">"Age"</span>: <span class="number">32</span>,</div><div class="line">    <span class="string">"Company"</span>: <span class="string">"IBM"</span>,</div><div class="line">    <span class="string">"Engineer"</span>: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 获取这个人的信息</span></div><div class="line"><span class="keyword">var</span> personAge = person.Age;</div><div class="line"><span class="comment">// 描述几个人</span></div><div class="line"><span class="keyword">var</span> members = [</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Name"</span>: <span class="string">"Bob"</span>,</div><div class="line">        <span class="string">"Age"</span>: <span class="number">32</span>,</div><div class="line">        <span class="string">"Company"</span>: <span class="string">"IBM"</span>,</div><div class="line">        <span class="string">"Engineer"</span>: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Name"</span>: <span class="string">"John"</span>,</div><div class="line">        <span class="string">"Age"</span>: <span class="number">20</span>,</div><div class="line">        <span class="string">"Company"</span>: <span class="string">"Oracle"</span>,</div><div class="line">        <span class="string">"Engineer"</span>: <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Name"</span>: <span class="string">"Henry"</span>,</div><div class="line">        <span class="string">"Age"</span>: <span class="number">45</span>,</div><div class="line">        <span class="string">"Company"</span>: <span class="string">"Microsoft"</span>,</div><div class="line">        <span class="string">"Engineer"</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">]</div><div class="line"><span class="comment">// 读取其中John的公司名称</span></div><div class="line"><span class="keyword">var</span> johnsCompany = members[<span class="number">1</span>].Company;</div><div class="line"><span class="comment">// 描述一次会议</span></div><div class="line"><span class="keyword">var</span> conference = &#123;</div><div class="line">    <span class="string">"Conference"</span>: <span class="string">"Future Marketing"</span>,</div><div class="line">    <span class="string">"Date"</span>: <span class="string">"2012-6-1"</span>,</div><div class="line">    <span class="string">"Address"</span>: <span class="string">"Beijing"</span>,</div><div class="line">    <span class="string">"Members"</span>: </div><div class="line">    [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"Name"</span>: <span class="string">"Bob"</span>,</div><div class="line">            <span class="string">"Age"</span>: <span class="number">32</span>,</div><div class="line">            <span class="string">"Company"</span>: <span class="string">"IBM"</span>,</div><div class="line">            <span class="string">"Engineer"</span>: <span class="literal">true</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="string">"Name"</span>: <span class="string">"John"</span>,</div><div class="line">            <span class="string">"Age"</span>: <span class="number">20</span>,</div><div class="line">            <span class="string">"Company"</span>: <span class="string">"Oracle"</span>,</div><div class="line">            <span class="string">"Engineer"</span>: <span class="literal">false</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="string">"Name"</span>: <span class="string">"Henry"</span>,</div><div class="line">            <span class="string">"Age"</span>: <span class="number">45</span>,</div><div class="line">            <span class="string">"Company"</span>: <span class="string">"Microsoft"</span>,</div><div class="line">            <span class="string">"Engineer"</span>: <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line"><span class="comment">// 读取参会者Henry是否工程师</span></div><div class="line"><span class="keyword">var</span> henryIsAnEngineer = conference.Members[<span class="number">2</span>].Engineer;</div></pre></td></tr></table></figure>
<p>关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。</p>
<blockquote>
<p>什么是JSONP？</p>
</blockquote>
<p>先说说JSONP是怎么产生的：</p>
<p>其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。</p>
<p>1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；</p>
<p>2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<script>、<img>、<iframe>）；</p>
<p>3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p>
<p>4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p>
<p>5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。</p>
<p>6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。</p>
<p>7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<p>如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。</p>
<hr>
<blockquote>
<p><strong>JSONP的客户端具体实现</strong></p>
</blockquote>
<p>不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：</p>
<p>1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。</p>
<p>远程服务器remoteserver.com根目录下有个remote.js文件代码如下：</p>
<p><code>alert(&#39;我是远程文件&#39;);</code></p>
<p>本地服务器localserver.com下有个jsonp.html页面代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://remoteserver.com/remote.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。</p>
<p>2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。</p>
<p>jsonp.html页面代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></div><div class="line">    <span class="keyword">var</span> localHandler = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">        alert(<span class="string">'我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：'</span> + data.result);</div><div class="line">    &#125;;</div><div class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://remoteserver.com/remote.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>remote.js文件代码如下：</p>
<p><code>localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});</code></p>
<p>运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。</p>
<p>很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。</p>
<p>3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。</p>
<p>看jsonp.html页面的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></div><div class="line">    <span class="comment">// 得到航班信息查询结果后的回调函数</span></div><div class="line">    <span class="keyword">var</span> flightHandler = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">        alert(<span class="string">'你查询的航班结果是：票价 '</span> + data.price + <span class="string">' 元，'</span> + <span class="string">'余票 '</span> + data.tickets + <span class="string">' 张。'</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</span></div><div class="line">    <span class="keyword">var</span> url = <span class="string">"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"</span>;</div><div class="line">    <span class="comment">// 创建script标签，设置其属性</span></div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">    script.setAttribute(<span class="string">'src'</span>, url);</div><div class="line">    <span class="comment">// 把script标签加入head，此时调用开始</span></div><div class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script); </div><div class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。</p>
<p>我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。</p>
<p>OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：</p>
<p><code>flightHandler({
    &quot;code&quot;: &quot;CA1998&quot;,
    &quot;price&quot;: 1780,
    &quot;tickets&quot;: 5
});</code></p>
<p>我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！</p>
<p>4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。</p>
<p>什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Untitled Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">jquery.min.js</span>"&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></div><div class="line">    jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">       $.ajax(&#123;</div><div class="line">            <span class="attr">type</span>: <span class="string">"get"</span>,</div><div class="line">            <span class="attr">async</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">url</span>: <span class="string">"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998"</span>,</div><div class="line">            <span class="attr">dataType</span>: <span class="string">"jsonp"</span>,</div><div class="line">            <span class="attr">jsonp</span>: <span class="string">"callback"</span>,<span class="comment">//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)</span></div><div class="line">            jsonpCallback:<span class="string">"flightHandler"</span>,<span class="comment">//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据</span></div><div class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</div><div class="line">                alert(<span class="string">'您查询到航班信息：票价： '</span> + json.price + <span class="string">' 元，余票： '</span> + json.tickets + <span class="string">' 张。'</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                alert(<span class="string">'fail'</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>是不是有点奇怪？</p>
<p>为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！</p>
<p>哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？</p>
<p>ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。</p>
<p>所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。</p>
<p>还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。</p>
<p>-摘自于  <a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" title="cnblogs">cnblogs</a></p>
</script></p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://dodoing.com/2016/11/30/JSONP的原理，JSON和JSONP区别，也许你会豁然开朗，含jQuery用例.html" data-id="cj4ruszt50001v0e9seu45cz6" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript-node-js-mongo/">javascript node.js mongo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript-node-js-redis/">javascript node.js redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/攻击与防御/">攻击与防御</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/javascript-node-js-mongo/" style="font-size: 10px;">javascript node.js mongo</a> <a href="/tags/javascript-node-js-redis/" style="font-size: 10px;">javascript node.js redis</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/攻击与防御/" style="font-size: 10px;">攻击与防御</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/06/了解http.html">了解http</a>
          </li>
        
          <li>
            <a href="/2017/07/05/js面向对象小结js面向对象小结.html">js面向对象小结js面向对象小结（工厂模式，构造函数，原型方法，继承）</a>
          </li>
        
          <li>
            <a href="/2017/07/05/JS构造函数内的方法与构造函数prototype属性上方法的对比.html">JS构造函数内的方法与构造函数prototype属性上方法的对比</a>
          </li>
        
          <li>
            <a href="/2017/06/15/彻底理解透彻js的原型与原型链.html">彻底理解透彻js的原型与原型链</a>
          </li>
        
          <li>
            <a href="/2017/06/15/hello-world.html">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 eoeos<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>